package mal

import (
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Add Anime
//
// Allows the authenticating user to add an anime to their anime list.
//
// URL:
// http://myanimelist.net/api/animelist/add/id.xml
//
// Formats:
// xml
//
// HTTP Method(s):
// POST
//
// Requires Authentication:
// true
//
// Parameters:
// id. Required. The id of the anime to add.
// Example: http://myanimelist.net/api/animelist/add/21.xml
// data. Required. A parameter specified as 'data' must be passed. It must contain anime values in XML format.
// Response:
// Will return the unique ID of the row generated by the insert.

// Anime Values (XML)

// <?xml version="1.0" encoding="UTF-8"?>
// <entry>
// 	<episode>11</episode>
// 	<status>1</status>
// 	<score>7</score>
// 	<downloaded_episodes></downloaded_episodes>
// 	<storage_type></storage_type>
// 	<storage_value></storage_value>
// 	<times_rewatched></times_rewatched>
// 	<rewatch_value></rewatch_value>
// 	<date_start></date_start>
// 	<date_finish></date_finish>
// 	<priority></priority>
// 	<enable_discussion></enable_discussion>
// 	<enable_rewatching></enable_rewatching>
// 	<comments></comments>
// 	<fansub_group></fansub_group>
// 	<tags>test tag, 2nd tag</tags>
// </entry>
// Parameters:
// episode. int
// status. int OR string. 1/watching, 2/completed, 3/onhold, 4/dropped, 6/plantowatch
// score. int
// downloaded_episodes. int
// storage_type. int (will be updated to accomodate strings soon)
// storage_value. float
// times_rewatched. int
// rewatch_value. int
// date_start. date. mmddyyyy
// date_finish. date. mmddyyyy
// priority. int
// enable_discussion. int. 1=enable, 0=disable
// enable_rewatching. int. 1=enable, 0=disable
// comments. string
// fansub_group. string
// tags. string. tags separated by commas

// AnimeData holds values such as score, episode and status that we want our
// anime entry to have when we add or update it on our list.
//
// Status is required and can be:
// 1/watching, 2/completed, 3/onhold, 4/dropped, 6/plantowatch
//
// DateStart and DateFinish require 'mmddyyyy' format
//
// EnableDiscussion and EnableRewatching can be: 1=enable, 0=disable
//
// Tags are comma separated: test tag, 2nd tag
type AnimeData struct {
	XMLName            xml.Name `xml:"entry"`
	Episode            int      `xml:"episode,omitempty"`
	Status             string   `xml:"status,omitempty"`
	Score              int      `xml:"score,omitempty"`
	DownloadedEpisodes int      `xml:"downloaded_episodes,omitempty"`
	StorageType        int      `xml:"storage_type,omitempty"`
	StorageValue       float64  `xml:"storage_value,omitempty"`
	TimesRewatched     int      `xml:"times_rewatched,omitempty"`
	RewatchValue       int      `xml:"rewatch_value,omitempty"`
	DateStart          string   `xml:"date_start,omitempty"`
	DateFinish         string   `xml:"date_finish,omitempty"`
	Priority           int      `xml:"priority,omitempty"`
	EnableDiscussion   int      `xml:"enable_discussion,omitempty"`
	EnableRewatching   int      `xml:"enable_rewatching,omitempty"`
	Comments           string   `xml:"comments,omitempty"`
	FansubGroup        string   `xml:"fansub_group,omitempty"`
	Tags               string   `xml:"tags,omitempty"`
}

func UpdateAnime(animeID int, data AnimeData) ([]byte, error) {
	xmlData, err := xml.MarshalIndent(data, "", "")
	if err != nil {
		return nil, fmt.Errorf("cannot marshal: %s", err)
	}

	const updateAnimeURL = "http://myanimelist.net/api/animelist/update/"
	resp, err := postAnime(updateAnimeURL, animeID, xmlData)
	if err != nil {
		return nil, fmt.Errorf("update anime failed: '', %s", string(resp), err)
	}
	fmt.Printf("REPONSE: %v\n", string(resp))

	return resp, nil
}

func AddAnime(animeID int, data AnimeData) ([]byte, error) {
	xmlData, err := xml.MarshalIndent(data, "", "")
	if err != nil {
		return nil, fmt.Errorf("cannot marshal: %s", err)
	}

	const addAnimeURL = "http://myanimelist.net/api/animelist/add/"
	resp, err := postAnime(addAnimeURL, animeID, xmlData)
	if err != nil {
		return nil, fmt.Errorf("add anime failed: '', %s", string(resp), err)
	}
	fmt.Printf("REPONSE: %v\n", string(resp))

	return resp, nil
}

// Fetches a fresh XML from MyAnimeList.net
func postAnime(postURL string, animeID int, data []byte) ([]byte, error) {
	v := url.Values{}
	v.Set("data", string(data))
	fmt.Printf("POST URL: %v\n", fmt.Sprintf("%s%d.xml", postURL, animeID))
	req, err := http.NewRequest("POST", fmt.Sprintf("%s%d.xml", postURL, animeID), strings.NewReader(v.Encode()))
	if err != nil {
		return nil, err
	}
	req.Header.Add("User-Agent", userAgent)
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	req.SetBasicAuth(username, password)

	resp, err := defaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return body, nil
}
